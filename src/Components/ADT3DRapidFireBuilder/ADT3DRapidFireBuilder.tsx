import React, {
    useCallback,
    useEffect,
    useMemo,
    useReducer,
    useState
} from 'react';
import MockAdapter from '../../Adapters/MockAdapter';
import ADT3DSceneAdapter from '../../Adapters/ADT3DSceneAdapter';
import {
    DeeplinkContextProvider,
    SceneThemeContextProvider,
    SceneViewContextProvider
} from '../../Models/Context';
import { WrapperMode } from '../3DV/SceneView.types';
import SceneViewWrapper from '../3DV/SceneViewWrapper';
import { ISceneViewProps } from '../../Models/Classes/SceneView.types';
import { useSceneViewContext } from '../../Models/Context/SceneViewContext/SceneViewContext';
import {
    ADT3DSceneBuilderReducer,
    defaultADT3DSceneBuilderState
} from '../ADT3DSceneBuilder/ADT3DSceneBuilder.state';
import { useAdapter } from '../../Models/Hooks';
import { SET_ADT_SCENE_CONFIG } from '../ADT3DSceneBuilder/ADT3DSceneBuilder.types';
import {
    I3DScenesConfig,
    ITwinToObjectMapping
} from '../../Models/Types/Generated/3DScenesConfiguration-v1.0.0';
import { ICardboardListItem } from '../CardboardList/CardboardList.types';
import { CardboardList } from '../CardboardList';
import { Stack, TextField } from '@fluentui/react';
import TwinPropertySearchDropdown from '../TwinPropertySearchDropdown/TwinPropertySearchDropdown';
import { DTID_PROPERTY_NAME } from '../../Models/Constants';

/** TO BE PLACED IN TYPES */
interface IADT3DRapidFireBuilderProps {
    adapter: ADT3DSceneAdapter | MockAdapter;
    sceneId: string;
    sceneViewProps: ISceneViewProps;
}

export interface MeshGroupItems {
    [key: string]: string[];
}

export interface MeshGroup {
    parent: string;
    children: string[];
}

export interface ElementMap {
    [key: string]: ITwinToObjectMapping;
}

/** END OF TYPES */

/** TO BE PLACED IN STYLES */
const gridStyle: React.CSSProperties = {
    display: 'grid',
    gridTemplateColumns: '1fr 1fr 1fr',
    gridTemplateRows: 'auto',
    gridTemplateAreas: `
    "header1 header2 header3"
  "content content content"
  `
};

const headerOne: React.CSSProperties = {
    gridArea: 'header1',
    height: 300,
    maxHeight: 300,
    overflow: 'auto',
    border: 'red 1px solid'
};
const headerTwo: React.CSSProperties = {
    gridArea: 'header2',
    height: 300,
    border: 'orange 1px solid'
};
const headerThree: React.CSSProperties = {
    gridArea: 'header3',
    height: 300,
    border: 'green 1px solid'
};
const content: React.CSSProperties = {
    gridArea: 'content',
    border: 'yellow 1px solid',
    height: 500
};
/** END OF STYLES */

const ADT3DRapidFireBase: React.FC<IADT3DRapidFireBuilderProps> = (props) => {
    const [state, dispatch] = useReducer(
        ADT3DSceneBuilderReducer,
        defaultADT3DSceneBuilderState
    );
    const { adapter, sceneId, sceneViewProps } = props;
    const [groupedMeshes, setGroupedMeshes] = useState<MeshGroupItems>();
    const [selectedMeshGroup, setSelectedMeshGroup] = useState<string>('');
    const [
        autogeneratedElements,
        setAutoGeneratedElements
    ] = useState<ElementMap>({});

    // Element value form
    const [elementDisplayNameValue, setElementDisplayNameValue] = useState('');
    const onChangeElementDisplayName = useCallback(
        (
            event: React.FormEvent<HTMLInputElement | HTMLTextAreaElement>,
            newValue?: string
        ) => {
            // Update value in textbox
            setElementDisplayNameValue(newValue || '');
            const newElement = { ...autogeneratedElements[selectedMeshGroup] };
            // Update value in state
            setAutoGeneratedElements((autogeneratedElements: ElementMap) => ({
                ...autogeneratedElements,
                [`${selectedMeshGroup}`]: newElement
            }));
        },
        []
    );

    /** Get config */
    const getScenesConfig = useAdapter({
        adapterMethod: () => adapter.getScenesConfig(),
        refetchDependencies: [adapter]
    });

    useEffect(() => {
        if (!getScenesConfig.adapterResult.hasNoData()) {
            const config: I3DScenesConfig = getScenesConfig.adapterResult.getData();
            dispatch({
                type: SET_ADT_SCENE_CONFIG,
                payload: config
            });
        } else {
            dispatch({
                type: SET_ADT_SCENE_CONFIG,
                payload: null
            });
        }
    }, [getScenesConfig?.adapterResult]);

    /** Create element draft objects */
    useEffect(() => {
        if (groupedMeshes) {
            const elementsToCreate: ElementMap = {};
            Object.keys(groupedMeshes).map((meshKey) => {
                elementsToCreate[meshKey] = {
                    displayName: `Element ${meshKey}`,
                    id: `${Math.random()}-element-${meshKey}`,
                    objectIDs: groupedMeshes[meshKey],
                    primaryTwinID: '',
                    type: 'TwinToObjectMapping'
                };
            });
            console.log(elementsToCreate);
            setAutoGeneratedElements(elementsToCreate);
        }
    }, [groupedMeshes]);

    const getModelUrl = () => {
        return state.config.configuration?.scenes.find((x) => x.id === sceneId)
            ?.assets[0].url;
    };

    // Grouped mesh functions
    const getGroupedMeshes = (meshes: MeshGroupItems) => {
        setGroupedMeshes(meshes);
    };

    const meshList = useMemo(() => {
        if (groupedMeshes) {
            return Object.keys(groupedMeshes).map((key) => {
                const viewModel: ICardboardListItem<MeshGroup> = {
                    ariaLabel: '',
                    item: {
                        parent: key,
                        children: groupedMeshes[key]
                    },
                    textPrimary: key,
                    textSecondary: groupedMeshes[key].join(),
                    onClick: () => {
                        setSelectedMeshGroup(key);
                        const selectedElement = autogeneratedElements[key];
                        setElementDisplayNameValue(selectedElement.displayName);
                    }
                };
                return viewModel;
            });
        } else {
            return [];
        }
    }, [groupedMeshes, autogeneratedElements]);

    return (
        <>
            {/* Grid */}
            <div style={gridStyle}>
                <div style={headerOne}>
                    <p>Mesh groups</p>
                    {/* <GroupedList
                        items={meshList}
                        onRenderCell={onRenderCell}
                        groups={groups}
                        styles={{
                            root: {
                                height: 240,
                                overflow: 'auto'
                            }
                        }}
                    /> */}
                    <CardboardList<MeshGroup>
                        listKey={'mesh-groupings'}
                        items={meshList}
                    />
                </div>
                <div style={headerTwo}>
                    <p>Element to create</p>
                    <Stack>
                        <TextField
                            value={elementDisplayNameValue}
                            onChange={onChangeElementDisplayName}
                        />
                    </Stack>
                </div>
                <div style={headerThree}>
                    <p>Twin select</p>
                    <TwinPropertySearchDropdown
                        adapter={adapter}
                        searchPropertyName={DTID_PROPERTY_NAME}
                    />
                </div>
                <div style={content}>
                    {state.config && (
                        <SceneViewWrapper
                            sceneViewProps={{
                                ...sceneViewProps,
                                modelUrl: getModelUrl(),
                                getToken: (adapter as any).authService
                                    ? () =>
                                          (adapter as any).authService.getToken(
                                              'storage'
                                          )
                                    : undefined,
                                allowModelDimensionErrorMessage: true
                            }}
                            wrapperMode={WrapperMode.Builder}
                            getGroupedMeshes={getGroupedMeshes}
                        />
                    )}
                </div>
            </div>
        </>
    );
};

export const ADT3DRapidFireBuilder: React.FC<IADT3DRapidFireBuilderProps> = (
    props
) => {
    return (
        <DeeplinkContextProvider>
            <SceneThemeContextProvider>
                <SceneViewContextProvider>
                    <ADT3DRapidFireBase {...props} />
                </SceneViewContextProvider>
            </SceneThemeContextProvider>
        </DeeplinkContextProvider>
    );
};
